# 記事自動改善機能 実装方針

## 概要

分析結果を元に、記事の修正まで自動で行う機能の実装方針を記載します。

## 背景

現在、分析結果として以下が提供されています：
- なぜ競合が上位なのか
- 追加すべき項目（理由、内容、参考URL）

これらの情報を元に、実際の記事修正まで自動で行うことで、ユーザーの作業負荷を大幅に削減できます。

## 機能概要

**「記事を修正する」ボタン**を追加し、以下の流れで実装：

1. ユーザーが分析結果画面で「記事を修正する」ボタンをクリック
2. 既存記事の構造を取得（分析時に保存、またはURLから再取得）
3. **サービス側でGemini API keyを使用**（ユーザーは入力不要）
4. Gemini 2.0 Flash Liteを使用して修正案を生成
5. **変更部分をコピペできる形式**で出力
6. ユーザーがコピーして記事に適用

**コスト**: 1記事あたり約**0.1円**（Gemini 2.0 Flash Lite使用時）

## 課題と制約

### 1. LLMコストとAPI key管理

**選択肢A: ユーザーがAPI keyを入力する方式**
- メリット: サービス側のコスト負担なし
- デメリット: ユーザーのハードルが高い（API key取得が必要）

**選択肢B: サービス側でAPI keyを管理する方式（推奨）**
- メリット: ユーザーのハードルが低い（ボタンを押すだけ）
- デメリット: サービス側のコスト負担
- **コスト**: 1記事あたり約0.1円（非常に低コスト）
- **実装方針**: サービス側でGemini API keyを管理し、ユーザーはボタンを押すだけ

**選択肢C: 有料プランのみに制限**
- メリット: コストを有料ユーザーに転嫁
- デメリット: 無料ユーザーは利用不可
- **実装方針**: 有料プランのみこの機能を利用可能にする

### 2. プラットフォームの多様性
- WordPress
- 自社サイト（CMS、静的サイトなど）
- Gitリポジトリ（PR作成）
- その他

### 3. 修正内容の種類
- **新規項目の追加**: 新しいセクションとして追加（比較的容易）
- **既存内容の改善**: 既存セクションを拡張・修正（難易度が高い）
- **構造の変更**: 記事全体の構造を変更（最も難しい）

## 実装方針

### Phase 1: 修正案の生成とプレビュー（MVP）

**目的**: ユーザーが修正案を確認してから適用できるようにする

**機能**:
1. 分析結果から「追加すべき項目」を抽出
2. 既存記事の構造を取得（分析時に保存されたデータ、またはURLから再取得）
3. **サービス側でGemini API keyを使用**（ユーザーは入力不要）
4. Gemini 2.0 Flash Liteを使用して修正案を生成
5. プレビューを表示（2つの形式）:
   - **コピペ可能な形式**: そのまま使用できる完全なMarkdown
   - **シンプルな形式**: 見出し、位置、内容を分けて表示
6. ユーザーが承認後に適用

**実装内容**:
- **既に環境変数 `GEMINI_API_KEY` が設定済み**（追加設定不要）
- 記事構造取得機能（分析時に保存、またはURLから再取得）
- 修正案生成API（`/api/article-improvement/generate`）
- プレビューUI（2つの形式を表示）
- コピー機能（変更点をコピーして記事に適用）

**技術スタック**:
- **Gemini 2.0 Flash Lite**（コスト削減、高速）
- 記事のHTML/Markdown解析（cheerio、remark等）
- 記事構造の取得（分析時に保存、またはURLから再取得）

### Phase 2: 基本的な記事修正機能

**目的**: 実際の記事を修正できるようにする

**機能**:
1. 記事の取得方法
   - URLから記事を取得（スクレイピング）
   - または、ユーザーが記事内容をコピペ
2. 修正案の適用
   - 新規セクションの追加（指定位置に挿入）
   - 既存セクションの拡張（慎重に実装）
3. 修正後の記事を表示・ダウンロード

**実装内容**:
- 記事取得機能
- 修正案適用ロジック
- 修正後の記事エクスポート機能

### Phase 3: プラットフォーム対応

**目的**: 各種プラットフォームに対応

#### 3.1 WordPress対応

**機能**:
- WordPress REST APIを使用して記事を取得・更新
- ユーザーがWordPressの認証情報を入力
- 修正案をWordPressに直接適用

**実装内容**:
- WordPress認証情報管理
- WordPress API連携
- 記事の取得・更新機能

#### 3.2 Git対応

**機能**:
- GitリポジトリにPRを作成
- 修正案をコミットしてPRとして提出
- ユーザーがGitHub/GitLabの認証情報を入力

**実装内容**:
- Git認証情報管理（Personal Access Token等）
- Git操作（clone、commit、push、PR作成）
- PR作成機能

#### 3.3 自社サイト対応

**機能**:
- 記事のHTML/Markdownを取得
- 修正案を適用
- 修正後のファイルをダウンロード

**実装内容**:
- 記事取得機能（スクレイピング、API連携等）
- 修正案適用機能
- ファイルエクスポート機能

## 実装の優先順位

1. **Phase 1（修正案の生成とプレビュー）**: 最優先
   - ユーザーが修正案を確認できる
   - コストを最小限に抑えられる
   - 実装が比較的容易

2. **Phase 2（基本的な記事修正機能）**: 次優先
   - 実際の記事修正が可能になる
   - 新規セクションの追加から実装

3. **Phase 3（プラットフォーム対応）**: 段階的に実装
   - ユーザーの要望に応じて優先順位を決定
   - WordPress → Git → 自社サイトの順で実装

## 技術的な考慮事項

### 1. API key管理（サービス側で管理）

**使用するAPI**:
- **Gemini 2.0 Flash Lite**（Google AI Studio）
- **サービス側でAPI keyを環境変数で管理**（ユーザーは入力不要）
- **既に環境変数 `GEMINI_API_KEY` が設定済み**

**セキュリティ**:
- 環境変数 `GEMINI_API_KEY` を使用（既に設定済み）
- サーバー側でのみ使用（クライアントには公開しない）
- Vercelの環境変数で管理

**実装案**:
```typescript
// 既存の実装を参考に（lib/gemini-diff-analyzer.ts、lib/llm-diff-analyzer.ts）
import { GoogleGenerativeAI } from "@google/generative-ai";

// 環境変数からAPI keyを取得（既に設定済み）
const geminiApiKey = process.env.GEMINI_API_KEY;

if (!geminiApiKey) {
  throw new Error('GEMINI_API_KEY is not set');
}

// 既存の実装と同様に初期化
const genAI = new GoogleGenerativeAI(geminiApiKey);

// モデル名は環境変数から取得（デフォルト: gemini-2.0-flash-lite）
const modelName = process.env.GEMINI_MODEL || "gemini-2.0-flash-lite";
const model = genAI.getGenerativeModel({ model: modelName });

// コンテンツ生成
const result = await model.generateContent(prompt);
const response = await result.response;
const text = response.text();
```

**レート制限の管理**:
- ユーザーごとに1日あたりの使用回数を制限（例: 無料ユーザー5回/日、有料ユーザー50回/日）
- または、有料プランのみ利用可能にする

### 2. 修正案生成のプロンプト設計

**重要なポイント**:
- 既存記事の構造を維持
- 自然な文章の流れを保つ
- 適切な位置に挿入
- 既存のスタイルに合わせる
- **変更点のみを出力**（context windowの制約を考慮）
- **実際にコピペできる形式**で出力

**LLM選択**:
- **Gemini 2.0 Flash Lite**を使用（コスト削減、高速）
- **サービス側でAPI keyを管理**（ユーザーは入力不要）

**既存記事構造の取得**:
- 分析時に記事の全文は取得されているが、現在は保存されていない
- **実装時に必要な対応**:
  1. 分析時に記事の全文（`ArticleContent`）を一時ストレージに保存
  2. または、記事改善案生成時にURLから再取得
  3. 記事構造（見出し一覧）を取得して、挿入位置を特定

**出力形式の方針**:
- 記事全体を出力するのではなく、**変更点のみを出力**
- これにより、context windowの制約を回避し、コストも削減
- ユーザーが既存記事に変更点を適用しやすい形式
- **2つの形式を提供**:
  1. **コピペ可能な形式**: そのままコピペして使用できる完全なMarkdown
  2. **シンプルな形式**: 見出し、位置、内容を分けて表示

**プロンプト例（Gemini 2.0 Flash Lite用）**:
```
あなたはSEO記事の改善専門家です。
以下の記事に対して、分析結果に基づいて改善案を生成してください。

【既存記事の構造】
{articleStructure}
- 見出し一覧: {headings}
- 記事URL: {articleUrl}

【追加すべき項目】
{improvementItems}

【要件】
1. 既存記事の構造とスタイルを維持する
2. 自然な文章の流れを保つ
3. 適切な位置に新しいセクションを追加する
4. 既存の内容を損なわないようにする
5. 実際にコピペして使用できる完全なMarkdown形式で出力する

【出力形式】
以下のJSON形式で変更点を出力してください：
{
  "changes": [
    {
      "type": "insert",
      "position": "after" | "before",
      "target": "既存の見出し（例: '## emoとは？'）",
      "content": "追加する完全なMarkdown形式の内容（見出しを含む）",
      "simpleFormat": {
        "section": "追加するセクションの見出し",
        "position": "既存の見出しの後/前",
        "content": "Markdown形式の本文"
      }
    }
  ]
}

例:
{
  "changes": [
    {
      "type": "insert",
      "position": "after",
      "target": "## emoとは？",
      "content": "## 日本語音声コマンド一覧\n\nemoロボットが理解できる日本語音声コマンドを、機能別に分類して一覧で提示します。\n\n### 基本操作\n\n- 「emo、写真撮って」: 写真を撮影します\n- 「emo、ダンスして」: ダンスを開始します\n...",
      "simpleFormat": {
        "section": "日本語音声コマンド一覧",
        "position": "## emoとは？の後",
        "content": "emoロボットが理解できる日本語音声コマンドを、機能別に分類して一覧で提示します。\n\n### 基本操作\n\n- 「emo、写真撮って」: 写真を撮影します\n- 「emo、ダンスして」: ダンスを開始します\n..."
      }
    }
  ]
}
```

### 3. 記事の構造解析と変更点の適用

**必要な機能**:
- HTML/Markdownの解析
- セクションの識別
- 挿入位置の決定
- 変更点の適用（差分適用）

**実装案**:
- Markdown: `remark`、`markdown-it`等
- HTML: `cheerio`、`jsdom`等
- 差分適用: `diff-match-patch`、`unified`等

**変更点の適用ロジック**:
1. 既存記事を解析して構造を把握
2. 変更点の指示（位置、内容）を解析
3. 指定された位置に変更点を適用
4. 修正後の記事を生成

**例**:
```typescript
// 変更点の適用
const changes = [
  {
    type: "insert",
    position: "after",
    target: "## emoとは？",
    content: "## 日本語音声コマンド一覧\n\nemoロボットが理解できる日本語音声コマンドを、機能別に分類して一覧で提示します。\n..."
  }
];

// 既存記事に適用
const updatedArticle = applyChanges(originalArticle, changes);
```

### 4. エラーハンドリング

**考慮事項**:
- API keyの無効性
- 記事の取得失敗
- LLM APIのレート制限
- 修正案の適用失敗

**実装**:
- 適切なエラーメッセージを表示
- リトライ機能
- フォールバック処理

## UI/UX設計

### 1. 修正案生成画面

```
[分析結果表示]
- なぜ競合が上位なのか
- 追加すべき項目（3個）

[修正案生成ボタン]
- 「記事を修正する」ボタン（API key入力不要）
- ローディング表示
- エラーハンドリング（API key未設定、レート制限等）

[修正案プレビュー]
- 2つの形式を表示:
  - **コピペ可能な形式**: そのまま使用できる完全なMarkdown
  - **シンプルな形式**: 見出し、位置、内容を分けて表示
- 適用位置の表示（既存記事のどの部分に適用されるか）
- 承認/拒否ボタン
```

### 2. 修正案適用画面

```
[修正案プレビュー]
- 変更点の表示（追加・修正・削除）
- 適用後のプレビュー（変更点を適用した状態）

[適用方法選択]
- [ ] 修正後の記事をダウンロード
- [ ] WordPressに適用
- [ ] Git PRを作成
- [ ] その他（カスタム）

[適用ボタン]
```

## コスト試算

### 1記事あたりのコスト（目安）

#### 基本コスト（Gemini 2.0 Flash Lite使用時）

**記事構造取得**:
- 分析時に既に取得済みの場合: **無料**
- URLから再取得する場合: **無料**（スクレイピング）

**修正案生成**:
- 入力トークン: 約5,000トークン
  - 既存記事構造（見出し一覧など）: 約1,000トークン
  - 分析結果（追加すべき項目）: 約2,000トークン
  - プロンプト: 約2,000トークン
- 出力トークン: 約500-1,000トークン（変更点のみ）

**Gemini 2.0 Flash Liteの価格**（2024年時点）:
- 入力: $0.075/1Mトークン
- 出力: $0.30/1Mトークン

**コスト計算**:
- 入力コスト: 5,000トークン × $0.075/1M = **$0.000375**
- 出力コスト: 1,000トークン × $0.30/1M = **$0.0003**
- **合計: 約$0.000675 = 約0.1円（日本円）**

#### 比較（GPT-4 Turbo使用時）

- 入力コスト: 5,000トークン × $10/1M = **$0.05**
- 出力コスト: 1,000トークン × $30/1M = **$0.03**
- **合計: 約$0.08 = 約12円（日本円）**

**コスト削減効果**:
- Gemini 2.0 Flash Liteを使用することで、**約99%コスト削減**
- 1記事あたり約0.1円で修正案を生成可能

#### 月間コスト試算（例）

**想定シナリオ**:
- ユーザー数: 100人
- 1ユーザーあたりの月間記事改善数: 10記事
- 合計: 1,000記事/月

**コスト**:
- 1記事あたり: $0.000675
- 月間合計: 1,000記事 × $0.000675 = **$0.675 = 約100円**

**無料枠の活用**:
- Gemini 2.0 Flash Liteの無料枠: 1分あたり15リクエスト、1日あたり1,500リクエスト
- 月間: 約45,000リクエスト（無料）
- 上記のシナリオ（1,000記事/月）は無料枠内で収まる可能性が高い

#### 実装時の考慮事項

1. **記事構造の保存**
   - 分析時に記事構造（見出し一覧）を保存することで、再取得コストを削減
   - 保存コスト: ほぼ無料（DBに数KBのデータを保存）

2. **キャッシュの活用**
   - 同じ記事に対して複数回改善案を生成する場合、キャッシュを活用
   - ただし、分析結果が更新される可能性があるため、キャッシュの有効期限を設定

3. **エラーハンドリング**
   - API呼び出し失敗時のリトライ
   - レート制限に達した場合の待機処理

### ユーザーへの案内

**サービス側でAPI keyを管理する場合**:
- ユーザーはAPI keyを入力する必要がない
- 「記事を修正する」ボタンを押すだけ
- コストはサービス側で負担（1記事あたり約0.1円）
- 有料プランのみ利用可能、または全ユーザーに提供（コストが低いため）

**利用制限**（必要に応じて）:
- 無料ユーザー: 1日あたり5回まで
- 有料ユーザー: 1日あたり50回まで
- または、有料プランのみ利用可能

## 今後の拡張可能性

1. **複数記事の一括改善**
   - 複数の記事を一度に改善

2. **改善履歴の管理**
   - 過去の改善履歴を保存
   - 改善前後の比較

3. **A/Bテスト機能**
   - 複数の改善案を生成
   - 効果を測定

4. **自動適用機能**
   - 一定の条件を満たす場合、自動で適用

## 実装スケジュール（目安）

- **Phase 1**: 2-3週間
- **Phase 2**: 1-2週間
- **Phase 3**: プラットフォームごとに1-2週間

## 参考資料

- [Gemini API Documentation](https://ai.google.dev/docs)
- [Google AI Studio](https://aistudio.google.com/)
- [WordPress REST API Handbook](https://developer.wordpress.org/rest-api/)
- [GitHub API Documentation](https://docs.github.com/en/rest)

