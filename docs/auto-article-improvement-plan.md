# 記事自動改善機能 実装方針

## 概要

分析結果を元に、記事の修正まで自動で行う機能の実装方針を記載します。

## 背景

現在、分析結果として以下が提供されています：
- なぜ競合が上位なのか
- 追加すべき項目（理由、内容、参考URL）

これらの情報を元に、実際の記事修正まで自動で行うことで、ユーザーの作業負荷を大幅に削減できます。

## 機能概要

**「記事を修正する」ボタン**を追加し、以下の流れで実装（✅ Phase 1は実装完了）：

1. ユーザーが分析結果画面で「記事を修正する」ボタンをクリック ✅
2. 既存記事の全文を取得（URLからスクレイピング、最初の3000文字に制限）✅
3. **サービス側でGemini API keyを使用**（ユーザーは入力不要）✅
4. Gemini 2.0 Flash Liteを使用して修正案を生成 ✅
5. **変更部分をコピペできる形式**で出力 ✅
6. モーダルでプレビュー表示、ユーザーがコピーして記事に適用 ✅

**コスト**: 1記事あたり約**0.3円**（Gemini 2.0 Flash Lite使用時）

## 課題と制約

### 1. LLMコストとAPI key管理

**選択肢A: ユーザーがAPI keyを入力する方式**
- メリット: サービス側のコスト負担なし
- デメリット: ユーザーのハードルが高い（API key取得が必要）

**選択肢B: サービス側でAPI keyを管理する方式（推奨）**
- メリット: ユーザーのハードルが低い（ボタンを押すだけ）
- デメリット: サービス側のコスト負担
- **コスト**: 1記事あたり約0.1円（非常に低コスト）
- **実装方針**: サービス側でGemini API keyを管理し、ユーザーはボタンを押すだけ

**選択肢C: 有料プランのみに制限**
- メリット: コストを有料ユーザーに転嫁
- デメリット: 無料ユーザーは利用不可
- **実装方針**: 有料プランのみこの機能を利用可能にする

### 2. プラットフォームの多様性
- WordPress
- 自社サイト（CMS、静的サイトなど）
- Gitリポジトリ（PR作成）
- その他

### 3. 修正内容の種類
- **新規項目の追加**: 新しいセクションとして追加（比較的容易）
- **既存内容の改善**: 既存セクションを拡張・修正（難易度が高い）
- **構造の変更**: 記事全体の構造を変更（最も難しい）

## 実装方針

### Phase 1: 修正案の生成とプレビュー（MVP）✅ 実装完了

**目的**: ユーザーが修正案を確認してから適用できるようにする

**機能**:
1. 分析結果から「追加すべき項目」と「なぜ競合が上位なのか」を取得
2. 既存記事の全文を取得（URLからスクレイピング、最初の3000文字に制限）
3. **サービス側でGemini API keyを使用**（ユーザーは入力不要）
4. Gemini 2.0 Flash Liteを使用して修正案を生成
5. モーダルでプレビューを表示（2つの形式）:
   - **コピペ可能な形式**: そのまま使用できる完全なMarkdown
   - **シンプルな形式**: 見出し、位置、内容を分けて表示
6. コピー機能で変更点をクリップボードにコピー

**実装内容**（実装済み）:
- **環境変数 `GEMINI_API_KEY` を使用**（既に設定済み）
- 記事全文取得機能（`ArticleScraper`を使用、fetchのみ、Playwright不使用）
- 修正案生成API（`/api/article-improvement/generate`）
- 修正案生成ロジック（`lib/article-improvement.ts`の`ArticleImprovementGenerator`）
- プレビューUI（モーダルで2つの形式を表示）
- コピー機能（変更点をクリップボードにコピー）

**技術スタック**:
- **Gemini 2.0 Flash Lite**（コスト削減、高速）
- 記事のスクレイピング（`ArticleScraper`、fetch API使用）
- 記事の全文を取得してLLMに提供（最初の3000文字に制限）

### Phase 2: 基本的な記事修正機能

**目的**: 実際の記事を修正できるようにする

**機能**:
1. 記事の取得方法
   - URLから記事を取得（スクレイピング）
   - または、ユーザーが記事内容をコピペ
2. 修正案の適用
   - 新規セクションの追加（指定位置に挿入）
   - 既存セクションの拡張（慎重に実装）
3. 修正後の記事を表示・ダウンロード

**実装内容**:
- 記事取得機能
- 修正案適用ロジック
- 修正後の記事エクスポート機能

### Phase 3: プラットフォーム対応

**目的**: 各種プラットフォームに対応

#### 3.1 WordPress対応

**機能**:
- WordPress REST APIを使用して記事を取得・更新
- ユーザーがWordPressの認証情報を入力
- 修正案をWordPressに直接適用

**実装内容**:
- WordPress認証情報管理
- WordPress API連携
- 記事の取得・更新機能

#### 3.2 Git対応

**機能**:
- GitリポジトリにPRを作成
- 修正案をコミットしてPRとして提出
- ユーザーがGitHub/GitLabの認証情報を入力

**実装内容**:
- Git認証情報管理（Personal Access Token等）
- Git操作（clone、commit、push、PR作成）
- PR作成機能

#### 3.3 自社サイト対応

**機能**:
- 記事のHTML/Markdownを取得
- 修正案を適用
- 修正後のファイルをダウンロード

**実装内容**:
- 記事取得機能（スクレイピング、API連携等）
- 修正案適用機能
- ファイルエクスポート機能

## 実装の優先順位

1. **Phase 1（修正案の生成とプレビュー）**: ✅ **実装完了**
   - ユーザーが修正案を確認できる
   - コストを最小限に抑えられる
   - 実装が比較的容易
   - **実装済み**: モーダルで修正案をプレビュー、コピー機能付き

2. **Phase 2（基本的な記事修正機能）**: 次優先（未実装）
   - 実際の記事修正が可能になる
   - 新規セクションの追加から実装

3. **Phase 3（プラットフォーム対応）**: 段階的に実装（未実装）
   - ユーザーの要望に応じて優先順位を決定
   - WordPress → Git → 自社サイトの順で実装

## 技術的な考慮事項

### 1. API key管理（サービス側で管理）

**使用するAPI**:
- **Gemini 2.0 Flash Lite**（Google AI Studio）
- **サービス側でAPI keyを環境変数で管理**（ユーザーは入力不要）
- **既に環境変数 `GEMINI_API_KEY` が設定済み**

**セキュリティ**:
- 環境変数 `GEMINI_API_KEY` を使用（既に設定済み）
- サーバー側でのみ使用（クライアントには公開しない）
- Vercelの環境変数で管理

**実装案**:
```typescript
// 既存の実装を参考に（lib/gemini-diff-analyzer.ts、lib/llm-diff-analyzer.ts）
import { GoogleGenerativeAI } from "@google/generative-ai";

// 環境変数からAPI keyを取得（既に設定済み）
const geminiApiKey = process.env.GEMINI_API_KEY;

if (!geminiApiKey) {
  throw new Error('GEMINI_API_KEY is not set');
}

// 既存の実装と同様に初期化
const genAI = new GoogleGenerativeAI(geminiApiKey);

// モデル名は環境変数から取得（デフォルト: gemini-2.0-flash-lite）
const modelName = process.env.GEMINI_MODEL || "gemini-2.0-flash-lite";
const model = genAI.getGenerativeModel({ model: modelName });

// コンテンツ生成
const result = await model.generateContent(prompt);
const response = await result.response;
const text = response.text();
```

**レート制限の管理**:
- ユーザーごとに1日あたりの使用回数を制限（例: 無料ユーザー5回/日、有料ユーザー50回/日）
- または、有料プランのみ利用可能にする

### 2. 修正案生成のプロンプト設計

**重要なポイント**:
- 既存記事の構造を維持
- 自然な文章の流れを保つ
- 適切な位置に挿入
- 既存のスタイルに合わせる
- **変更点のみを出力**（context windowの制約を考慮）
- **実際にコピペできる形式**で出力

**LLM選択**:
- **Gemini 2.0 Flash Lite**を使用（コスト削減、高速）
- **サービス側でAPI keyを管理**（ユーザーは入力不要）

**既存記事構造の取得**（実装済み）:
- 記事改善案生成時にURLから記事の全文を取得（`ArticleScraper`を使用）
- 記事の全文（最初の3000文字）と見出し構造をLLMに提供
- 分析結果（「なぜ競合が上位なのか」と「追加すべき項目」）をblobストレージから取得

**出力形式の方針**:
- 記事全体を出力するのではなく、**変更点のみを出力**
- これにより、context windowの制約を回避し、コストも削減
- ユーザーが既存記事に変更点を適用しやすい形式
- **2つの形式を提供**:
  1. **コピペ可能な形式**: そのままコピペして使用できる完全なMarkdown
  2. **シンプルな形式**: 見出し、位置、内容を分けて表示

**プロンプト例（Gemini 2.0 Flash Lite用）**:
```
あなたはSEO記事の改善専門家です。
以下の記事に対して、分析結果に基づいて改善案を生成してください。

【既存記事の構造】
{articleStructure}
- 見出し一覧: {headings}
- 記事URL: {articleUrl}

【追加すべき項目】
{improvementItems}

【要件】
1. 既存記事の構造とスタイルを維持する
2. 自然な文章の流れを保つ
3. 適切な位置に新しいセクションを追加する
4. 既存の内容を損なわないようにする
5. 実際にコピペして使用できる完全なMarkdown形式で出力する

【出力形式】
以下のJSON形式で変更点を出力してください：
{
  "changes": [
    {
      "type": "insert",
      "position": "after" | "before",
      "target": "既存の見出し（例: '## emoとは？'）",
      "content": "追加する完全なMarkdown形式の内容（見出しを含む）",
      "simpleFormat": {
        "section": "追加するセクションの見出し",
        "position": "既存の見出しの後/前",
        "content": "Markdown形式の本文"
      }
    }
  ]
}

例:
{
  "changes": [
    {
      "type": "insert",
      "position": "after",
      "target": "## emoとは？",
      "content": "## 日本語音声コマンド一覧\n\nemoロボットが理解できる日本語音声コマンドを、機能別に分類して一覧で提示します。\n\n### 基本操作\n\n- 「emo、写真撮って」: 写真を撮影します\n- 「emo、ダンスして」: ダンスを開始します\n...",
      "simpleFormat": {
        "section": "日本語音声コマンド一覧",
        "position": "## emoとは？の後",
        "content": "emoロボットが理解できる日本語音声コマンドを、機能別に分類して一覧で提示します。\n\n### 基本操作\n\n- 「emo、写真撮って」: 写真を撮影します\n- 「emo、ダンスして」: ダンスを開始します\n..."
      }
    }
  ]
}
```

### 3. 記事の構造解析と変更点の適用

**必要な機能**:
- HTML/Markdownの解析
- セクションの識別
- 挿入位置の決定
- 変更点の適用（差分適用）

**実装案**:
- Markdown: `remark`、`markdown-it`等
- HTML: `cheerio`、`jsdom`等
- 差分適用: `diff-match-patch`、`unified`等

**変更点の適用ロジック**:
1. 既存記事を解析して構造を把握
2. 変更点の指示（位置、内容）を解析
3. 指定された位置に変更点を適用
4. 修正後の記事を生成

**例**:
```typescript
// 変更点の適用
const changes = [
  {
    type: "insert",
    position: "after",
    target: "## emoとは？",
    content: "## 日本語音声コマンド一覧\n\nemoロボットが理解できる日本語音声コマンドを、機能別に分類して一覧で提示します。\n..."
  }
];

// 既存記事に適用
const updatedArticle = applyChanges(originalArticle, changes);
```

### 4. エラーハンドリング

**考慮事項**:
- API keyの無効性
- 記事の取得失敗
- LLM APIのレート制限
- 修正案の適用失敗

**実装**:
- 適切なエラーメッセージを表示
- リトライ機能
- フォールバック処理

## UI/UX設計

### 1. 修正案生成画面

```
[分析結果表示]
- なぜ競合が上位なのか
- 追加すべき項目（3個）

[修正案生成ボタン]
- 「記事を修正する」ボタン（API key入力不要）
- ローディング表示
- エラーハンドリング（API key未設定、レート制限等）

[修正案プレビュー]
- 2つの形式を表示:
  - **コピペ可能な形式**: そのまま使用できる完全なMarkdown
  - **シンプルな形式**: 見出し、位置、内容を分けて表示
- 適用位置の表示（既存記事のどの部分に適用されるか）
- 承認/拒否ボタン
```

### 2. 修正案適用画面

```
[修正案プレビュー]
- 変更点の表示（追加・修正・削除）
- 適用後のプレビュー（変更点を適用した状態）

[適用方法選択]
- [ ] 修正後の記事をダウンロード
- [ ] WordPressに適用
- [ ] Git PRを作成
- [ ] その他（カスタム）

[適用ボタン]
```

## コスト試算

### Gemini 2.0 Flash Liteの料金（2024年時点）

- **入力**: $0.075 / 100万トークン
- **出力**: $0.30 / 100万トークン

### 1回実行あたりのトークン数推定

#### 入力トークン数

1. **プロンプトテンプレート**: 約500トークン
   - システムプロンプトと要件説明

2. **既存記事の情報**: 約3,000-4,000トークン
   - URL: 約20トークン
   - タイトル: 約30トークン
   - 見出し構造: 約100-300トークン（見出しの数による）
   - 記事の全文（最初の3000文字）: 約1,500-3,000トークン
     - 日本語は1文字あたり約0.5-1トークン

3. **分析結果**: 約500-1,500トークン
   - whyCompetitorsRankHigher: 約200-800トークン（分析結果の詳細度による）
   - recommendedAdditions: 約300-700トークン
     - 通常3-5項目
     - 各項目: セクション名、理由、内容概要、参考URL

**入力トークン数合計**: 約4,000-6,000トークン（平均: **約5,000トークン**）

#### 出力トークン数

1. **JSON形式の変更案**: 約3,000-8,000トークン
   - 通常3-5項目の追加提案
   - 各項目: 見出し＋本文（約500-1,500トークン）
   - JSONの構造: 約200-500トークン

**出力トークン数合計**: 約3,000-8,000トークン（平均: **約5,000トークン**）

### 1回実行あたりのコスト計算

#### 標準的なケース（入力5,000トークン、出力5,000トークン）

- **入力コスト**: 5,000トークン × $0.075 / 1,000,000 = **$0.000375**
- **出力コスト**: 5,000トークン × $0.30 / 1,000,000 = **$0.0015**
- **合計**: **$0.001875 ≈ $0.002**（約**0.3円**、1ドル=150円として）

#### 大きめのケース（入力6,000トークン、出力8,000トークン）

- **入力コスト**: 6,000トークン × $0.075 / 1,000,000 = **$0.00045**
- **出力コスト**: 8,000トークン × $0.30 / 1,000,000 = **$0.0024**
- **合計**: **$0.00285 ≈ $0.003**（約**0.45円**）

#### 小さめのケース（入力4,000トークン、出力3,000トークン）

- **入力コスト**: 4,000トークン × $0.075 / 1,000,000 = **$0.0003**
- **出力コスト**: 3,000トークン × $0.30 / 1,000,000 = **$0.0009**
- **合計**: **$0.0012**（約**0.18円**）

### 月間コスト試算

#### 想定シナリオ1: 小規模利用

- ユーザー数: 50人
- 1ユーザーあたりの月間記事改善数: 5記事
- 合計: 250記事/月

**コスト**:
- 1記事あたり: $0.002（平均）
- 月間合計: 250記事 × $0.002 = **$0.50 = 約75円**

#### 想定シナリオ2: 中規模利用

- ユーザー数: 100人
- 1ユーザーあたりの月間記事改善数: 10記事
- 合計: 1,000記事/月

**コスト**:
- 1記事あたり: $0.002（平均）
- 月間合計: 1,000記事 × $0.002 = **$2.00 = 約300円**

#### 想定シナリオ3: 大規模利用

- ユーザー数: 500人
- 1ユーザーあたりの月間記事改善数: 20記事
- 合計: 10,000記事/月

**コスト**:
- 1記事あたり: $0.002（平均）
- 月間合計: 10,000記事 × $0.002 = **$20.00 = 約3,000円**

### 比較（GPT-4 Turbo使用時）

- 入力コスト: 5,000トークン × $10/1M = **$0.05**
- 出力コスト: 5,000トークン × $30/1M = **$0.15**
- **合計: 約$0.20 = 約30円（日本円）**

**コスト削減効果**:
- Gemini 2.0 Flash Liteを使用することで、**約99%コスト削減**
- 1記事あたり約0.3円で修正案を生成可能

### 無料枠の活用

Gemini APIの無料枠（利用可能な場合）:
- 1分あたり: 15リクエスト
- 1日あたり: 1,500リクエスト
- 月間: 約45,000リクエスト

上記のシナリオ1-2は無料枠内で収まる可能性があります。

### コスト最適化のポイント（実装済み）

1. **記事の全文を3000文字に制限**: 実装済み（context windowを考慮）
2. **モデルの選択**: Gemini 2.0 Flash Liteを使用（コスト効率が高い）
3. **不要なデータの除外**: 競合記事のスクレイピングを行わない（実装済み）

### まとめ

- **1回実行あたり**: 約**$0.002 = 約0.3円**
- **コスト効率**: 非常に低コストで実用的
- **月間1,000記事**: 約300円
- **月間10,000記事**: 約3,000円

非常に低コストで実用的な機能として提供可能です。

### ユーザーへの案内

**サービス側でAPI keyを管理する場合**:
- ユーザーはAPI keyを入力する必要がない
- 「記事を修正する」ボタンを押すだけ
- コストはサービス側で負担（1記事あたり約0.3円）
- 有料プランのみ利用可能、または全ユーザーに提供（コストが低いため）

**利用制限**（必要に応じて）:
- 無料ユーザー: 1日あたり5回まで
- 有料ユーザー: 1日あたり50回まで
- または、有料プランのみ利用可能

## 今後の拡張可能性

1. **複数記事の一括改善**
   - 複数の記事を一度に改善

2. **改善履歴の管理**
   - 過去の改善履歴を保存
   - 改善前後の比較

3. **A/Bテスト機能**
   - 複数の改善案を生成
   - 効果を測定

4. **自動適用機能**
   - 一定の条件を満たす場合、自動で適用

## 実装スケジュール

- **Phase 1**: ✅ **完了**（実装済み）
- **Phase 2**: 未実装（今後の拡張）
- **Phase 3**: 未実装（今後の拡張）

## 参考資料

- [Gemini API Documentation](https://ai.google.dev/docs)
- [Google AI Studio](https://aistudio.google.com/)
- [WordPress REST API Handbook](https://developer.wordpress.org/rest-api/)
- [GitHub API Documentation](https://docs.github.com/en/rest)

